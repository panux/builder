package main

import (
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/panux/builder/pkgen"
	"github.com/panux/builder/pkgen/buildmanager"
	"github.com/panux/go-makefile"
)

func main() {
	//index/load package generator files
	rpki, err := buildmanager.IndexDir("pkgs")
	if err != nil {
		log.Fatalf("Failed to index directory: %q\n", err)
	}

	mfb := makefile.NewBuilder()

	//generate makefile header
	mfb.Comment().Line("AUTOGENERATED DO NOT EDIT").
		Line("This Makefile contains rules to build the packages")
	mfb.BlankLine().BlankLine()
	allrule := mfb.NewRule(makefile.RawText("all"))
	mfb.BlankLine().BlankLine()

	//generate build rules
	tlst, err := (&builder{
		mf:  mfb.SectionBuilder(),
		pki: rpki,
	}).buildPkgs()
	if err != nil {
		log.Fatalf("Failed to generate package rules: %q\n", err)
	}
	allrule.Deps = tlst

	//save Makefile
	f, err := os.OpenFile("Makefile", os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed to open Makefile: %q\n", err)
	}
	defer f.Close()
	_, err = mfb.WriteTo(f)
	if err != nil {
		log.Fatalf("Failed to save Makefile: %q\n", err)
	}
}

//variable containing command to run to build something
var bvar = makefile.MakeVar("BUILDCMD")

//output directory variable
var odirvar = makefile.MakeVar("OUTPUT")

type builder struct {
	mf  *makefile.Builder
	pki buildmanager.RawPackageIndex
}

//generate a command to build a pkgen
func (b *builder) cmdBuild(pkgname string, pkgpath string, host pkgen.Arch, build pkgen.Arch) *makefile.Command {
	opath := makefile.JoinText("/", odirvar.Sub(), makefile.FilePath(pkgname))
	return makefile.NewCmd(bvar.Sub()).
		AddArg(makefile.RawText("--host")).AddArg(host).
		AddArg(makefile.RawText("--build")).AddArg(build).
		AddArg(makefile.RawText("--pkgen")).AddArg(makefile.FilePath(pkgpath)).
		AddArg(makefile.RawText("--out")).AddArg(opath).
		SetNoPrint()
}

//add a rule to build a package
func (b *builder) addBuildRule(name string, pk *pkgen.PackageGenerator) bool {
	deps, err := b.pki.DepWalker().Walk(name)
	if err != nil {
		log.Printf("Ignoring build for %q: %q", name, err)
		return false
	}
	for i, d := range deps {
		deps[i] = getPrimaryPackage(b.pki[d])
	}
	deps = undup(deps)
	dept := make([]makefile.Text, len(deps))
	for i, d := range deps {
		pts := []makefile.Text{makefile.RawText(d), pk.BuildArch}
		if b.pki[d].Pkgen.Builder == "bootstrap" {
			pts = append(pts, makefile.RawText("bootstrap"))
		}
		dept[i] = makefile.JoinText("-", pts...)
	}
	path := b.pki[name].Path
	npts := []makefile.Text{makefile.RawText(name), pk.BuildArch}
	if pk.Builder == "bootstrap" {
		npts = append(npts, makefile.RawText("bootstrap"))
	}
	b.mf.NewRule(makefile.JoinText("-", npts...)).
		Print(makefile.JoinText(" ", //format: BUILD path/to/thing.yaml x86_64
			makefile.RawText("BUILD"),
			makefile.FilePath(path),
			pk.BuildArch,
		)).
		AddCmd(b.cmdBuild(name, path, pk.HostArch, pk.BuildArch)).
		Phony().
		Deps = dept
	return true
}

func getPrimaryPackage(ent *buildmanager.RawPkent) string {
	return filepath.Base(filepath.Dir(ent.Path))
}

func undup(strs []string) []string {
	sort.Strings(strs)
	for i := 0; i < len(strs); i++ {
		if i+1 != len(strs) {
			if strs[i+1] == strs[i] {
				strs = append(strs[:i+1], strs[i+2:]...)
			}
		}
	}
	return strs
}

func (b *builder) buildEnt(ent *buildmanager.RawPkent) {
	//get supported arch set
	aset := ent.Pkgen.Arch
	if aset == nil {
		aset = pkgen.SupportedArch
	}
	//loop through arch set and generate arch-specific rules
	rnames := []makefile.Text{}
	for _, a := range aset {
		pk, err := ent.Pkgen.Preprocess(a, a)
		if err != nil {
			log.Printf("skipping rules for package %q: %q", ent.Path, err)
			return
		}
		if b.addBuildRule(getPrimaryPackage(ent), pk) {
			npts := []makefile.Text{makefile.RawText(getPrimaryPackage(ent)), pk.BuildArch}
			if pk.Builder == "bootstrap" {
				npts = append(npts, makefile.RawText("bootstrap"))
			}
			rnames = append(rnames, makefile.JoinText("-", npts...))
		}
	}
	//create build all rule
	b.mf.NewRule(makefile.JoinText("-",
		makefile.RawText(getPrimaryPackage(ent)),
		makefile.RawText("all"),
	)).Phony().
		Deps = rnames
}

//adds build targets for all packages and returns a list of the all targets
func (b *builder) buildPkgs() ([]makefile.Text, error) {
	com := "Autogenerated package targets"
	b.mf.Comment().Line(com).Line(strings.Repeat("-", len(com)))
	pks := make(map[string]struct{})
	for _, ent := range b.pki {
		pks[getPrimaryPackage(ent)] = struct{}{}
	}
	ns := make([]string, len(pks))
	i := 0
	for n := range pks {
		ns[i] = n
		i++
	}
	sort.Strings(ns)
	rulenames := []makefile.Text{}
	for _, n := range ns {
		ent := b.pki[n]
		if ent == nil {
			log.Printf("Skipping package %q: package not recognized\n", n)
			continue
		}
		b.buildEnt(ent)
		rulenames = append(rulenames, makefile.JoinText("-",
			makefile.RawText(getPrimaryPackage(ent)),
			makefile.RawText("all"),
		))
	}
	return rulenames, nil
}
